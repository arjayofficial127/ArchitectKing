Chapter 2
=========

Data Structures
---------------

### Containers shape behavior

### What this chapter is

This chapter is not a catalog of structures.It is not a comparison table.It is not about memorizing when to use what.

This chapter explains **why containers matter**.

Data structures are not implementation details.They are **behavioral decisions**.

The core truth
--------------

A data structure is not just a way to store data.

It is a **promise** about:

*   access
    
*   ordering
    
*   duplication
    
*   absence
    
*   cost
    

When you choose a data structure, you choose behavior‚Äîwhether you intended to or not.

Containers are constraints
--------------------------

Every container answers questions implicitly:

*   Can there be duplicates?
    
*   Does order matter?
    
*   Can items be missing?
    
*   Is lookup fast or slow?
    
*   Is mutation expected?
    

You do not answer these questions with comments.You answer them with **structure**.

üß† **Mental Model**A data structure encodes rules without asking permission.

Why systems drift here
----------------------

Most developers choose data structures by habit.

*   Arrays because they are familiar
    
*   Objects because they are convenient
    
*   Lists because they are flexible
    

Habit is not reasoning.

‚ö†Ô∏è **Common Drift**When containers are chosen casually, rules migrate into code.

That is how conditionals multiply.

Structure before algorithm
--------------------------

Many developers jump from data directly to logic.

That is backwards.

First ask:

*   What relationships exist?
    
*   What must be unique?
    
*   What must be ordered?
    
*   What must be fast?
    
*   What must be stable?
    

Only after the container is correct does logic become simple.

üß† **Architect‚Äôs Note**Good algorithms often emerge automatically from correct structure.

The cost dimension
------------------

Every data structure trades something.

*   Time vs space
    
*   Simplicity vs flexibility
    
*   Read performance vs write performance
    

Ignoring cost does not remove it.It only makes it unpredictable.

üß† **Perspective**Performance problems are often structural, not computational.

Mutability and containment
--------------------------

Some containers invite mutation.Some resist it.

This matters.

A mutable container:

*   spreads responsibility
    
*   increases coupling
    
*   hides state changes
    

An immutable container:

*   constrains behavior
    
*   localizes change
    
*   clarifies ownership
    

Neither is ‚Äúbetter.‚ÄùBut one must be **chosen deliberately**.

When structure lies
-------------------

A dangerous moment in any system is when:

*   the container allows something
    
*   but the domain forbids it
    

Example:

*   duplicates allowed when uniqueness is required
    
*   ordering implied where none exists
    
*   absence treated as presence
    

This mismatch forces logic to compensate.

üß† **Common Drift**Validation code is often an apology for poor structure.

Minimal practice (again, no code)
---------------------------------

**Problem:**‚ÄúYou are storing registered users. Each user must be unique by email. Order does not matter. Lookups are frequent.‚Äù

Before choosing anything, answer:

*   What must never happen?
    
*   What must be fast?
    
*   What must be impossible by design?
    

If your container allows violation, the system will eventually violate it.

What beginners gain here
------------------------

*   Relief from guessing
    
*   A reason containers exist
    
*   Fewer ‚Äúwhy is this hard?‚Äù moments
    

What experienced developers recognize
-------------------------------------

*   Why certain bugs cluster
    
*   Why validation grows endlessly
    
*   Why performance fixes feel reactive
    

The container was wrong.

What this chapter deliberately avoids
-------------------------------------

*   Specific language structures
    
*   Library comparisons
    
*   Premature optimization
    
*   Academic taxonomy
    

Those are secondary.

Closing
-------

Data structures are not about data.

They are about **rules made physical**.

When rules live in structure:

*   code simplifies
    
*   errors decrease
    
*   systems calm down
    

When rules live in logic:

*   complexity accumulates
    
*   behavior surprises
    
*   systems drift
    

Choose containers carefully.

They speak even when your code is silent.

### Next Chapter

**Chapter 3 ‚Äî Algorithms & Complexity**_When structure is fixed, cost becomes visible._